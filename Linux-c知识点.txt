Linux C知识点:
===========================================================================

内存布局:
高地址
---------------------
命令行参数与环境变量
栈:局部变量,返回值,形参
堆:动态分配的内存块
未初始化的数据段:未初始化的全局变量,由exec初始化为0或NULL,属于静态分配
已初始化的数据段:已初始化的全局变量和静态变量,由exec从程序文件读入
正文段:存储CPU执行的机器指令,通常只可读,由exec从程序文件读入
---------------------
低地址

---------------------------------------------------------------------------
网络字节序大小端:
内存增长方向 低 --> 高
         0x12345678 大端字节序 --> 网络字节序取首地址内容为0x12
         0x78563412 小端字节序 --> x86主机取首地址内容为0x78

---------------------------------------------------------------------------
GDB使用:

---------------------------------------------------------------------------
GCC使用:
---------------------------------------------------------------------------
高并发编程:

select接口:
#include <sys/select.h>
#include <sys/time.h>
int select(int maxfdp1,fd_set *readset,fd_set *writeset,fd_set *exceptset,const struct timeval *timeout)

参数maxfdp1指定待测试的描述字个数，它的值是待测试的最大描述字加1

参数readset、writeset和exceptset指定我们要让内核测试读、写和异常条件的描述字。如果对某一个的条件不感兴趣，就可以把它设为空指针
struct fd_set可以理解为一个集合，这个集合中存放的是文件描述符，可通过以下四个宏进行设置:
          void FD_ZERO(fd_set *fdset);          //清空集合
          void FD_SET(int fd, fd_set *fdset);   //将一个给定的文件描述符加入集合之中
          void FD_CLR(int fd, fd_set *fdset);   //将一个给定的文件描述符从集合中删除
          int  FD_ISSET(int fd, fd_set *fdset);  // 检查集合中指定的文件描述符是否可以读写

timeout告知内核等待所指定描述字中的任何一个就绪可花多少时间:
永远等待下去：仅在有一个描述字准备好I/O时才返回,为此，把该参数设置为空指针NULL
等待一段固定时间：在有一个描述字准备好I/O时返回,但是不超过由该参数所指向的timeval结构中指定的秒数和微秒数
根本不等待：检查描述字后立即返回，这称为轮询;为此,该参数必须指向一个timeval结构，而且其中的定时器值必须为0

每次调用select前都要重新设置文件描述符和时间，因为事件发生后，文件描述符和时间都被内核修改

poll接口:
# include <poll.h>
int poll ( struct pollfd * fds, unsigned int nfds, int timeout)

struct pollfd {
int fd;         /* 文件描述符 */
short events;         /* 等待的事件 */
short revents;       /* 实际发生了的事件 */
}; 

poll的机制与select类似，与select在本质上没有多大差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是poll没有最大文件描述符数量的限制。
poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，
而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大

epoll接口:
#include <sys/epoll.h>
int epoll_create(int size);
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);

epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。
每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。
如何避免不必要的内存拷贝就很重要，在这点上，epoll是通过内核于用户空间mmap同一块内存实现的
epoll不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表)
epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大
---------------------------------------------------------------------------
同步异步/阻塞非阻塞:

同步异步关注的是消息通信机制:
异步指的是,在调用发出后,被调用者主动通知调用者,如通过回调处理返回结果
同步指的是,在调用发出后,调用者主动等待调用的返回结果

阻塞非阻塞关注的是程序在等待调用结果时的状态:
非阻塞指的是,在没有得到调用返回结果前,当前调用不会阻塞当前线程
阻塞指的是,在没有得到调用返回结果前,当前线程会被挂起

---------------------------------------------------------------------------
